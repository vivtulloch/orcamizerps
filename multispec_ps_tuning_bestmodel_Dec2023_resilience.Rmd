---
title: "Orca_tuneparams_Nov2023_calibrate to fishing"
author: "Viv Tulloch"
date: "2023-11-27"
output: html_document
---


https://course.mizer.sizespectrum.org/build/find-species-parameters.html

## Create a mizer model

```{r message=FALSE}
try(unload("mizerExperimental"), silent = TRUE)
remotes::install_github("sizespectrum/mizerExperimental", quiet = TRUE)
library(mizerExperimental)
library(tidyverse)
```



```{r}
#Open model 
cur_model <-readParams("C:/~/orcamizerps_upd/bestmodel_231127_fishingpars_tuneparams.rds")
#species_params(params) |> select(erepro)

```


```{r FALSE}
#remotes::install_github('sizespectrum/mizerExperimental', ref = 'tuneMR')
#library(mizerExperimental)
#tuneParams(cm_tuned)
```


### TUNING RESILIENCE!

We need to decide what reproduction parameters we should set to start our tuning. We will follow the approach of Jacobsen et al. 2016 and initially set the reproductive efficiency erepro to the same value for all species.

We use the setBevertonHolt() function to set the values for erepro. That function automatically also adjusts the values for R_max to keep the steady state reproduction rate Rdd  the same, 
If we try to set the value for erepro very low, the setBevertonHolt() function will issue a warning. Because we want all species to have the same value, we choose a value that is larger than those required. So we choose erepro = 0.43


```{r}
cel_model<-cur_model
#getReproductionLevel(cel_model)
cel_model <- setBevertonHolt(cel_model, erepro = 0.43)
getReproductionLevel(cel_model)
species_params(cel_model) |> select(erepro, R_max)

```
Remember: the reproduction level is the ratio between RDD and R_max and can vary between 0 and 1. It tells us how close the actual reproduction (after applying density dependence) is to the theoretical maximum, set by R_max. So instead of using the getReproductionLevel() function we could also have done the calculation ourselves:


```{r}
getRDD(cel_model) / species_params(cel_model)$R_max
```

We can also look how close the density dependent reproduction rate RDD is to the density independent reproduction rate RDI:


```{r}
getRDI(cel_model) / getRDD(cel_model)

```
Tuning reproduction level
We now want to adjust the reproduction levels so that the resilience of the species in our model matches expectations.

Exploring yield curves
To measure the resilience of our species to fishing, we will change the fishing mortality for one species at a time and check how their yields change in response. We keep the fishing mortality for the other species fixed. For our selected species we run through a range of fishing mortalities. For each fishing mortality we run the projection until the system has settled down to a new steady state. Then we calculates the yield in that steady state. After doing that for all fishing mortalities we can plot all the results in a graph showing yield on the y axis versus fishing mortality F on the x axis. The plotYieldVsF() function does all that for us. Here we plot the yield curve for haddock:

```{r}
plotYieldVsF(cel_model, species = "Pacific_Herring_All", 
             F_range = seq(0.01, 0.15, 0.01))
```
Convergence was achieved in 7.5 years.
F = 0.03 - maximum - otherwise animals don't have enough food

BUT
pacific herring FMSY = 
0.54, 0.78, 0.45, 0.55, 0.56 https://waves-vagues.dfo-mpo.gc.ca/library-bibliotheque/40685147.pdf


We refer to the yield achieved in the steady state as the sustainable yield (SY) because it can be sustained indefinitely. The sustainable yield for this species has a maximum (MSY) at a fishing mortality of about 0.3. We refer to this value as FMSY. This is close enough to the value of 0.35 that is given for FMSY in the ICES advice for our haddock stock.

Next we look at perch, for which the DFO advice gives a value for FMSY of only 0.109 or 0.091
https://oceana.ca/wp-content/uploads/sites/24/canadas_marine_fisheries_low-res_final.pdf
```{r}
plotYieldVsF(cel_model, species = "Perch", 
             F_range = seq(0.01, 0.2, 0.02))
```




```{r}
getReproductionLevel(cel_model)["Perch"]
# First we save current reproduction level into a vector 
rep_level <- getReproductionLevel(cel_model)
# then we replace our species' reproduction level with a new value 
rep_level["Perch"] <- 0
# and assign it back to the model 
cel_model <- setBevertonHolt(cel_model, 
                             reproduction_level = rep_level)

# and plot F curves again
plotYieldVsF(cel_model, species = "Perch", 
               F_range = seq(0.01, 0.2, 0.02))
```





```{r}

```



```{r}

paramsn <- setInitialValues(cur_model, sim)

#read in time-averaged  catches 
#params<- cur_model
cdat<-read.csv(
  "C:/Users/vtulloch/Dropbox/UBC/Projects/Orca_salmon_modelling/07_sizespectra/Viv_sizespectra_model/Puget_Sound/spp_Aug2023_CM/fisheries/ts_fisheries_rev_avyield_rmzoo.csv") ### units: tonnes

# the fishing moratlty rates are already stored in the param object as
paramsn @species_params$catchability<-cdat$catchability
paramsn @species_params$catchability


species_params(paramsn)$yield_observed <- cdat$yield_observed
paramsn @species_params$yield_observed
paramsn @species_params$biomass_observed

paramsn2 <- calibrateYield(paramsn)

#plotYieldVsSpecies(paramsn2)
plotYieldObservedVsModel(paramsn2)
```


plotYieldVsSpecies(paramsn2)




```{r}
df1<-species_params(paramsn2)
write.csv(df1,
  "C:/Users/vtulloch/Dropbox/UBC/Projects/Orca_salmon_modelling/07_sizespectra/Viv_sizespectra_model/Puget_Sound/spp_Aug2023_CM/bestmodel_outputparams_231127_addfishinpars.csv") ### units: tonnes
```



Species are coexisting. This is in part because we applied a stronger  Rmax effect for larger species. You can play with the above parameters but but it would take a lot of trial an error to achieve the right combination to get the biomass or catches similar to the observations.

 - but pinnipeds are being outcompeted????

#### Step 2. Calibrate the carrying capacity of the background resource spectrum, \kappa, by minimising the error between the modelled and observed  abundance, biomass or catches. 

We could explore the effects further using Rshiny app, where we also have a plot of the biomass or catch data. First lets' look at the basic diagnostics and tune kappa and erepro to make sure the feeding levels are high enough for each species. 


```{r}
plotBiomassVsSpecies(paramsn2)
cur_model <- calibrateBiomass(paramsn2)
#cur_model <- matchBiomasses(cur_model)
plotBiomassVsSpecies(cur_model)
plotYieldVsSpecies(cur_model)
#tuneParams(params)
# is there a way to save the final chosen values?
params@resource_params$kappa
```


need to update gear_params catchability
catchability
0.001465922,1.49E-06,0.020425786,0.006316173,0.006369784,0.001124779,0.031044642,0.121768151,0.020000653,0.032180443,0.024686121,0.013064699,0.008152937,0.007719593,0.013376173,0,0,0,0,0

```{r}
gear_params(paramsn2)$yield_observed <- cdat$yield_observed

 gear_params(paramsn2)$catchability <- cdat$catchability
 gear_params(paramsn2)
 plotYieldVsSize(paramsn2)
```


```{r}
cur_model <- steady(paramsn2)
plotSpectra(cur_model)
 
```

```{r}

 
```








```{r}
df1<-species_params(cur_model)
write.csv(df1,
  "C:/Users/vtulloch/Dropbox/UBC/Projects/Orca_salmon_modelling/07_sizespectra/Viv_sizespectra_model/Puget_Sound/spp_Aug2023_CM/bestmodel_outputparams_231127_addfishinpars_upd.csv") ### units: tonnes
saveParams(cur_model, "bestmodel_231127_fishingpars_tuneparams.rds")
```



















```{r}
# run without fishing
sim2 <- project(cur_model, t_max = 100, effort =1, t_save=3)

plot(sim2)
animateSpectra(sim2, total = TRUE, power = 1)#, 
               #ylim = c(1e-8, NA), wlim = c(1e-3, NA))

 
```
try a bigger kappa? 38911829949.3564


> cur_model@resource_params$kappa
[1] 45062646192
[2] 33911829949

#### Step 3. Calibrate the maximum recruitment, \Rmax, which will affect the relative biomass of each species (and, combined with the fishing parameters, the catches) by minimising the error between observed and estimated catches or biomasses. We could also include kappa in our estimation here (as in Blanchard et al 2104 & Spence et al 2016) but instead we will use the value that seemed OK in terms of feeding levels in the shiny app, roughly log10(11.5). Same goes for erepro, a value of 1e-2 seemed ok.

try the course method

```{r}
tuneParams(params)
#getReproductionLevel(params)
#species_params(params) |> select(erepro)
getRDI(params)/getRDD(params)

```



This might take AWHILE. Go watch some Netflix.

```{r}


# change kappa and erepro based on shiny epxloration
 params@species_params$erepro[] <-1e-3
  params <- setParams(params,kappa=33911829949.3564)

# define the initial parameters to send to optimisation code below

# we need 12 Rmaxs, log10 scale
vary <- log10(1000*params@resource_params$kappa*params@species_params$w_inf^-1)
#vary<-runif(10,3,22) # or use completley made up values, same for each species test for effects of initial values

#the following getError function combines the steps of the optimisastion above - this time with the multispecies model and output the predicted size spectrum

getError <- function(vary,params=initparam,dat=cdat$yield_observed,data_type="catch",timetorun=100) {
  params@species_params$R_max[]<-10^vary[1:22]
  sim <- project(params, effort = 1, t_max = timetorun, dt=0.1)
          ## what kind of data and output do we have?
          if (data_type=="Biomass") {
          output <-getBiomass(sim)[timetorun,]   #could change to getBiomass if appropriate, also check units.
          }
          #if (data_type=="catch") {
         #output <-getYield(sim)[timetorun,]*1e6 #### CHECK UNITS !! grams per year? the data are in tonnes per year so converting to tonnes.
         # }
  pred <- log(output)
  dat  <- log(dat)

  # sum of squared errors, here on log-scale of predictions and data (could change this or use other error or likelihood options)
   discrep <- pred - dat

   discrep <- (sum(discrep^2))
  
  # can use a strong penalty on the error to ensure we reach a minimum of 10% of the data (biomass or catch) for each species
  #if(any(pred < 0.1*dat)) discrep <- discrep + 1e10
  
    return(discrep)

   }

## test it

initparams <- params

#err<-getError(vary,params,dat=cdat$yield_observed,data_type="catch")
#err
err<-getError(vary,params,dat=rep(100,22),data_type="biomass")
#test
err



# this time carry out optimisation, using optim(), with catches
vals<-optim(par=vary,getError,params=initparams,method ="L-BFGS-B",lower=c(rep(3,22)),upper= c(rep(20,22)))



# plug back into model
# make sure kappa and erepro are the same
params@species_params$erepro[] <-1e-4
params <- setParams(params,kappa=33911829949.3564)
# optim values:
params@species_params$R_max <- 10^vals$par[1:22] 
# set the param object
params<-setParams(params)
sim <- project(params, effort = 1, t_max = 500, dt=0.1)
plot(sim)

# and without fishing?
sim_uf <- project(params, effort = 0, t_max = 500, dt=0.1)
plot(sim_uf)

# save vals - may want to repeat this setp depending on diagnostics, after changing some parameters
saveRDS(vals,"optim_vals.RDS")

# save params - may want to repeat this setp depending on diagnostics, after changing some parameters
saveRDS(params,"optim_param.RDS")
saveRDS(sim,"optim_sim.RDS")


```




#### Step 4. Check that the physiological recruitment, \RDI, is much higher than the realised recruitment, \RDD. High RDI/RDD ratio.




```{r}
#params<- readRDS("optim_param.RDS")
#sim <- readRDS("optim_sim.RDS")
getRDI(cm_tuned)/getRDD(cm_tuned)

# seems like the right ballpark according to protocal

params2<-cm_tuned

# # if needed change erepro & plug back into model
 params2@species_params$erepro[] <-1e-3
 params2 <- setParams(params2)
 sim2 <- project(params2, effort = 1, t_max = 100, dt=0.1)
 plot(sim2)

```